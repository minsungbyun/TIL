default method:

- 기존 프로젝트에 영향을 끼치지 않으면서 기존 규칙에
- 새 메서드를 추가할 때 유용한다.
- 인터페이스에서 미리 구현한 메서드이기 때문에
  // 클래스에서 구현을 생략할 수 있다.
- 반대로 구현을 강제할 수 없다는 것이 단점이다.

  - 오버라이딩 해도 되고 안해도 된다.

  ```java
  interface MyInterface3 {
  void m1();

  default void m2() {
    System.out.println("MyInterface3.m2()");
    }
  }
  ```

- 어 그러면 추상 클래스랑 비슷하지 않나요?

  - 추상클래스는 extends 다중 상속이 안되고 인터페이스는 implements 다중 상속이 가능하다
  - 인스턴스 필드,메서드 선언이 불가능하다.
    다 스태틱이다, 객체생성 안된다.

    사용하려는 객체가 같은 인터페이스를 구현(사용규칙에 따라 작성)하였다면,
    // 다음과 같이 동일한 사용규칙에 따라 메서드를 호출할 수 있어 편리하다.
    // 호출에 일관성이 있어 유지보수에 좋다.

프로그램을 짜다가 인터페이스를 만나게 되면,
// - 누가 호출자이고 누가 피호출자인지 확인하라.
// - 본인이 맡은 개발 일이 호출자를 만드는 것인지
// 아니면 피호출자를 만드는 것인지 확인하라.

중복 메서드가 오버로딩 규칙을 위반할 경우 다중 구현 불가

1. 파라미터 타입,개수,순서가 다른 경우 같은 이름의 메서드를 중복 정의 할 수 있다.
2. 파라미터명은 상관없다.
3. 리턴타입도 상관없다.




## 인터페이스와 추상클래스의 콜라보

```java
 interface ProtocolA {
    void rule1();
    void rule2();
    void rule3();
    void rule4();
  }
```

```java
// 추상클래스에서 인터페이스의 규칙을 모두 미리 구현해 둔다.
  // 물론 최소 상태로 구현한다.
  abstract class AbstractProtocolA implements ProtocolA {
    @Override
    public void rule1() {}

    @Override
    public void rule2() {}

    @Override
    public void rule3() {}

    @Override
    public void rule4() {}
  }
```

```java
class ProtocolAImpl extends AbstractProtocolA {
    // 이 방식의 장점은 오버라이딩을 통해
    // 인터페이스 규칙 중 필요한 규칙만 구현할 수 있다.
    @Override
    public void rule2() {
      System.out.println("ProtocolAImpl.rule2()");
    }
  }
```

```java
public class Exam0120 {
  void test() {
    ProtocolAImpl obj = new ProtocolAImpl();

    // 수퍼 클래스가 인터페이스를 구현했다면,
    // 그 서브 클래스는 자동으로 인터페이스를 구현한 것이 된다.
    // 증명!
    //
    ProtocolA a = obj;

    a.rule2();
  }

  public static void main(String[] args) {
    new Exam0120().test();
  }
}
```

## 인터페이스와 추상클래스의 콜라보2

1) 인터페이스 정의
2) 추상 클래스로 인터페이스의 일부 규칙 구현하기
3) 인터페이스 직접 구현하기
4) 인터페이스 간접 구현
5) 인터페이스 규칙에 따라 구현체 사용하기









## 인터페이스와 디폴트

인터페이스를 바꾸게 되면 인터페이스를 구현한 기존 클래스에 영향을 끼친다.

인터페이스의 메서드를 변경하거나 제거, 추가하는 순간 이 인터페이스를 구현한 모든 클래스들에서 컴파일 오류가 발생하게 된다.

자기가 만든 인터페이스를 다른 개발자들이 그들 프로젝트에 사용하는 입장이라면?

그 사람들에게 영향 끼치겠죠
그렇다고 해서 계속 옛날 규칙을 가져갈 수 없고,
새 프로젝트에는 변경된 규칙으로 클래스를 만들고 싶다.






상속을 이용하여 규칙을 추가할 때,
- 서브 인터페이스를 통해 새 규칙을 추가한다.
- 새 인터페이스에 맞는 메서드를 따로 정의해야 한다.


새 규칙을 새 인터페이스(예: Computer2)로 정의할 순 있지만,
그렇게 하면 기존에 진행한 모든 프로젝트들과 호환되지 않는 문제가 발생한다.
  
기존 규칙을 변경하되, 기존 구현체(기존 규칙에 따라 작성한 클래스)에는 영향을 끼치고 싶지 않을 때
바로 다음 문법을 사용하라!

"디폴트 메서드(default method)" - Java8에서 추가한 문법이다.



default 메서드의 용도는
기존에 정의된 인터페이스에 새 규칙을 추가할 때
기존 프로젝트에 영향을 끼치지 않기 위함이다.
따라서 새 인터페이스를 정의할 때는 default의 사용을 자제해야 한다.

  강제로 정의하게 만들 수 없는 것이 문제이다.
  인터페이스의 의미가 사라지게 된다. 그래서 신중하게 사용해야한다.


디폴트 메서드를 추가할 때 간단하게 코드를 작성할 수 있지만,
  //    클래스처럼 뭔가 진짜 일을 하는 코드를 작성하는 것은 좋지 않다.
  //    그냥 다음과 같이 빈 메서드를 만들라!


인터페이스에서 스태틱 메서드는 보통 그 인터페이스를 구현한 객체를 다루는 일을 한다.
클래스에 있는 스태틱메서드 보다 좁게 사용된다.
규칙을 다루는 스태틱 메서드가 필요한 경우 사용


언제 인터페이스에서 스태틱메서드 - 그 인터페이스의 구현체를 다룰 때
클래스에서 스태틱메서드 - 그 클래스의 객체를 다룰 때





give and take
어댑터 패턴 - 코딩할 내용은 많아지지만 인터페이스의 규칙을 구현하도록 강제할 수 있다.
인터페이스 디폴트 메서드 - 코딩의 편리함을 취한다. 그 대신 인터페이스의 존재 이유인 규칙 강제를 할 수 없다.