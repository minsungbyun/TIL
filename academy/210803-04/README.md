## 27일차(2021-08-03,화)

---

- 실전 프로젝트(eomcs-java-project)
  - 08-b. `Composite` 디자인 패턴 : 적용 후(계속)
  - 08-c. `Composite` 디자인 패턴 : 익명 클래스 활용
  - 08-d. `Composite` 디자인 패턴 : 스태틱 멤버를 인스턴스 멤버로 전환

## 알게 된 점

---

- 패턴 = 유사한 형태 이러이러한 내용으로 하니까 잘 되더라
- 클래스 상속관계 의존관계를 어떻게 설계할 것인가?

  - 처음부터 제로베이스에서 시작하는거 아니다. 우리가 필요한것은 선배들의 경험을 내 것을 받아들이고 실무경험을 쌓고 우리만의 방법을 찾는 것이 순서다. 무조건 내가 처음부터 창시한다? nono

- 직접 접근하지말고 상속받은 슈퍼클래스의 타이틀을 호출하라

삭제 = 삭제는 보이드 대신 메뉴 객체를 준다. 만약에 삭제 못했으면 null한다. 주소를 가지고 한다. 삭제할 때
전 세계 개발자들은 void 대신 주소 리턴한다. 받아쓸라면 쓰고 아니면 말아

- 생성자 오버로딩이 필요 개발자들에게 선택권을 준다.

- 한번에 적용하지 않고, 동작하는 여부를 테스팅 한것을 테스트 한 후, 본 프로젝트에 적용한다.

- 여러가지 기능 구현후 while로 반복할지 써줘라

- 리스너 만들어라 = 옵저버 패턴

- 리스너 = 특정 객체에 상태가 변경되었을 때 보고를 받는
  야 메뉴아이템! 사용자가 실행요청 오면 나한데 메서드 호출해줘

  - 리스너1은 m1()을 호출해달라고해 , 리스너2는 m2()를 호출해달라고해 그럼 어떻게 하라는 거임?
    새로 만들때 마다 변경할 수도없고 ;;
  - 리스너의 메서드가 각각 다르다면 MenuItem을 정의하는 입장에서 호출할 메서드를 결정할 수 없어서
    코딩을 할 수 없다.
  - 해결방안 - 호출할 메서드의 규칙을 통일한다. (인터페이스의 등장)

- 메서드 호출 규칙을 정의하는 문법 / 인터페이스는 규칙이다.

- 인터페이스는 왜 등장하게 되었는가?

- 필수적으로 바꿔야할 사항이 아니라면
  인스턴스 변수중에서 뜨문뜨문 기본 값을 변경해야할경우 세터로 변경한다. 느슨하게 변경해라.
  아니면 생성자로 바꾼다.

- 반복문 안쓴다 if else 안쓴다.. 나중에는

- 중첩클래스 장점 = 바깥 클래스의 자원을 공유할 수 있다.

  - 그 클래스의 멤버인 양 사용할 수 있다.

- 중첩 클래스 로컬 클래스 = 여러 개 사용할 수 있는데 근데 인스턴스를 한 번 밖에 사용하지 않는다면 익명 클래스 써
- 로컬 클래스는 접근 제한자 못써

## 28일차(2021-08-04,수)

---

- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
  - 상속 관계가 있는 클래스의 레퍼런스와 인스턴스
- 실전 프로젝트(eomcs-java-project)
  - 09-a. 자료 구조 다루기 I : 배열 크기 변경
  - 09-b. 자료 구조 다루기 I : 연결리스트 적용

## 알게 된 점

---

- type = 클래스 , 인터페이스 , 배열 , 기본형

  - 주소를 저장하는 크기 4byte or 8byte(32bit or 64bit)
  - 클래스의 종류를 따지지 않고 고정됨 (offset : 상대적인 위치)
  - 명세서에 나와있지는 않다.

- 왜 클래스마다 주소 크기가 같을까?

  - 인스턴스 주소를 저장하는 공간이 같으니까 (대한민국 어디에 있는 주소던 체계는 같다.)
  - primitive type은 주소에 따라 저장 바이트가 다름(byte, int , long)

- 상위 객체는 하위 객체를 가리킬 수 있다.
- 상위 타입의 객체를 가리키지 못한다.

- `>>`는 1은 2로 나눈다는 뜻이다

- 배열 복사의 문제점

  - 가비지가 늘어난다!

- 링크드리스트로 하면 노드를 연결하면서 연결하기 때문에 배열이 필요없다.

- 객체를 리턴한다, 객체를 파라미터로 넘긴다, 객체를 저장한다 > 객체 "주소"

- 다음 노드 주소는 그 노드의 next에 있다.

- 노드로 for문과 같이 찾는 법

  - node head부터 시작해서 찾아들어간다 node가 null이 아닐 때 까지!

- 가장 평범한 것 부터 고민

[노드 삭제]

1. 주소를 삭제한 다음 노드의 주소로 바꾼다.
2. 삭제할 노드의 주소를 null로 바꾼다.
3. 마지막 노드를 삭제할 경우 tail을 앞으로 당겨준다.
4. 맨 앞 노드를 삭제할 경우 head를 뒤로 밀어준다.

- 캡슐화 - 복잡한 코드를 빼낸다 메서드를

예1)

```java
if (node.next != null) {
node.next = null; // 다음 노드와의 연결을 끊는다.
} else { // 삭제할 노드가 마지막 노드라면
tail = prev; // 이전 노드를 마지막 노드로 설정한다.
}

if (node == tail) { // 현재 노드가 tail이라면
tail = prev; // 이전 노드를 마지막 노드로 설정한다.
}
break;
}
```

예2)

```java
if (node == tail) { // 현재 노드가 tail이라면
    tail = prev; // 이전 노드를 마지막 노드로 설정한다.
    }
    break;
    }

배열 부분
if (this.size == this.boards.length) { // 꽉 차면 새로 만든다.
// 기존 배열보다 50% 더 큰 배열을 만든다.
Board[] arr = new Board[this.boards.length + (this.boards.length >> 1)];

      // 기존 배열의 값을 새 배열로 복사한다.
      for (int i = 0; i < this.size; i++) {
        arr[i] = this.boards[i];
      }

      // 기존 배열 대신 새 배열 주소를 저장한다.
      // 물론 이렇게 함으로써 기존 배열은 가비지가 될 것이다.
      this.boards = arr;
      System.out.println("새 Board[] 객체를 만듦!");


    }

this.boards[this.size++] = board;
}
```

- 특정 클래스 안에서만 사용할 클래스라면 패키지 멤버 클래스로 만들지마라. (패키지 멤버 클래스로 따로 뺄필요 없다)
- 그 클래스 안에 선언하라 = 중첩 클래스(로컬 클래스)로 선언하라 (스태틱 / 논스태틱) 그리고 인스턴스를 1번만 쓸꺼면 익명 클래스로 선언하라.

- 링크드리스트 = 주소 다루는 것을 연습하기 좋다.
