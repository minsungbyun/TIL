## 36일차(2021-08-17,화)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex11(c:Exam0310 ~ e): 중첩 클래스, 로컬 클래스 사용법


## 알게 된 점
___

- nested class , inner class, local class

- inner 객체는 바깥 객체의 주소를 가지고 있다.
    - 바깥클래스명.this를 기억해라

- 인스턴스 메서드를 호출하려면 반드시 해당 클래스의 인스턴스 주소가 필요!!
- 인스턴스 멤버는 인스턴스 주소를 사용한다.
- this가 생략되어서 바로 호출하는 것 처럼 보인다.

- 인스턴스 메서드는 인스턴스 주소를 담고 있는 this 변수가 있다. 그래서 inner class 를 사용할 수 있다.
- X obj = this.new X();

- 바깥 클래스의 인스턴스를 필요로 하면 논스태틱 중첩 클래스 만들고
인스턴스를 필요로 하지 않으면 스태틱 중첩 클래스 만들어라

- import는 클래스를 로딩하는 것이 아니다.
컴파일러에게 클래스의 위치를 알려주는 것이다.

- 노출을 줄이면 줄일수록 유지보수에 좋다.

- 컴파일이 끝나면 중첩 클래스는 별개의 클래스 파일로 추출된다.
- 추출된 클래스는 제약 조건이 붙는다. (A클래스 내에서만 쓸 수 있다.)

- 자바에서는 클래스 블럭 하나당 하나의 클래스 파일이 생긴다.

- 로컬클래스의 순서대로 이름이 붙는다.(A$1X.class)

1. 인스턴스 메서드의 로컬 클래스

바깥 클래스의 인스턴스 주소를 저장할 필드와 생성자가 추가된다. 
```java
A outer;
X(A outer){}
```

2. 스태틱 메서드의 로컬 클래스
바깥 클래스의 인스턴스 주소를 저장할 필드와 생성자를 추가하지 않는다.. 





- 중첩 클래스에 대한 오해들
    - 메서드가 호출될 때 클래스가 로딩된다? nono
    - 이미 컴파일 될 때 추출되었음

- 로컬 클래스의 .class 파일명
    - [바깥클래스명]$[정의된순서][로컬클래스명].class


- 바깥에 있는 인스턴스 필드를 사용할 것인가의 여부
- 중첩클래스는 앞에 static 이냐 non-static이냐로 결정
- 하지만 로컬 클래스는 어떻게 구별할까?
    - 로컬 클래스가 인스턴스 메서드라면? inner클래스처럼 
    - 로컬 클래스가 스태틱 메서드라면? 바깥 클래스의 주소를 담을 필드와 생성자가 없다.

 로컬 클래스에서는 바깥 메서드의 로컬 변수를 사용할 수 있다.
 1) final 로 선언된 경우
 2) final 로 선언된 것은 아니지만 값을 한 번만 할당한 경우.
 값을 여러 번 할당한 경우에는 접근할 수 없다.


클래스도 상속 받고 인터페이스도 구현하는 익명 클래스를 만들 수 있을까?
    // => 안된다.
    // => 둘 중 하나만 상속 받거나 구현해야지, 동시에 다 할 수 없다.
    여러 개의 인터페이스를 구현할 수 있을까?
    // => 안된다.

