## 📌 31일차(2021-08-09,월)

---

- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
  - ex07: 추상 클래스와 추상 메서드

## 📌 알게 된 점

---

- 객체지향 분석 설계에서는
  인스턴스 필드를 다루는 인스턴스 메서드를 연산자라고 한다.

- 추상화가 무너진다? > 적절하게 접근을 통제함으로서 해결

ex) 환자정보 - 키, 몸무게, 성별 등등 만약 키 몸무게가 무효한 값이라면 치명적이다. (추상화가 무너진다)

- 향후 변경가능성에 대해서 어떤 구조로 작성하는게 유지보수에 도움을 주는가? 가능한 최소한의 터치로 바꾸게끔
- 필드보다 메서드를 통한 변경이 유지보수가 좋다.
- lombok - 실무에서 쓴다. (게터 세터를 보다 더 간결하게 작성하기 위함)

- 만들어놓고 보니까 아 겹치네 수퍼클래스로 정의하자
  추상클래스의 레퍼런스 변수가 있다? 서브 클래스의 인스턴스를 받겠다는 뜻

- 추상클래스는 인스턴스를 만들 수 없다.
  하지만 레퍼런스 변수는 선언 가능 / 왜? 다형적 변수 가능 (유연하다)
- 구현 클래스 (= concrete class)

추상클래스를 만든 개발자의 의도는?

1. 내가 구현해놨는데 그냥 쓰던가 아니면 오버라이딩 하던가
2. 추상메서드는 너희가 구현해서 써

- 객체지향을 이해한다 = 클래스 관계도를 이해한다.

- 추상클래스인데 대부분의 기능은 구현되있어
  나머지 중요한 부분 템플릿으로 남겨둔다.

- 추상 클래스 , 추상 메서드?를 사용하였다? 템플릿 메서드
- 템플릿 메서드 패턴 = 상위클래스는 추상 클래스(기본흐름정의) 구현은 서브 클래스에게 맡긴다.
- 큰 흐름은 슈퍼클래스가 작은 흐름은 서브 클래스

- 소트를 어떤 것을 하냐에 따라서 속도가 달라진다.
  알고리즘 = 10가지 방식

- 코드 몰라도 그래픽하게 눈에 익혀라 , 코드를 먼저 본다고 이해되지는 않는다.
- 정렬 - bubble , quick , insert , Merge , select
- 자료구조 - linkedlist , stack, queue
- 탐색 : 이진 탐색 트리
- 해시 : 해시테이블

- 해시코드 : 인스턴스마다 고유하게 부여되는 번호

- 인스턴스 주소를 알아볼 수 있는 방법 ? 자바에서는 없다.

- toString()에 있는 16진수 값은 주소가 아니다!

- 개발을 하다 보면 인스턴스의 현재 값을 간단히 확인하고 싶을 경우가 있다.

  - 그럴 경우 toString()을 오버라이딩 하라! (클래스명@인스턴스 식별자)

- 도메인 = 게터 세터 , toString()까지 오버라이딩한다.

- equals도 오버라이딩 하지 않으면 인스턴스 주소를 비교한다.

- String와 wrapper 클래스는 equals() 오버라이딩 하였다.
- StringBuffer 클래스는 equals()를 오버라이딩 하지 않았다.

- println()에 String이 아닌 객체를 넘기면,

  - println()에서 내부적으로 그 객체에 대해 toString()을 호출하여 그 리턴 값을 출력한다.

- 해시코드 = 디지털 지문
- 데이터를 특별한 수학공식으로 계산해 만든 정수값 (원래 데이터를 요약한 값) 원래 데이터보다 크기가 작다.
- 서로 다른 데이터가 같은 해시 값을 가질 수 있다.
- 해시 알고리즘 = 해시 값을 생성하는 수학공식(MD4, MD5, SHA, PGP...)
- 그래서 어디에 쓸건데?
  - 데이터 동일 여부 검사에 쓴다.
  - 요약데이터를 비교하는게 오리지널 바이트로 비교하는 것 보다 속도가 빠르다.(정확도는 떨어진다) 타협점을 찾아서 비교
