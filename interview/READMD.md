## 📌 필수 질문 List
1. 1분 자기소개 해주세요
2. 차별화된 본인의 강점을 설명해주세요
3. 왜 우리회사에 지원하셨어요?
4. 성격의 장단점이 뭔가요?
5. 마지막 할 말 있으신가요?
-------------------------------------------------------------------

항상 지원자의 입장과 면접관의 입장을 나눠서 생각하자!

## 📌 1분 자기소개 - 면접의 전략 (45초 ~ 55초 적당)
- 첫인상을 결정하는 시간인만큼 중요하다. 
- 사람마다 첫 인상때문에 좌지우지되는 경우도 있음
- 여러분을 파악할 시간이다.

속지마;; => 준비하신것 말고 진짜 자기소개 해보세요 > 준비한대로 하자
면접관은 미리 당신의 자소서를 읽어 볼 수 없다. 

1분자기소개를 하면서 귀는 열고 눈으로 지원서 훓어본다.

나의 필드 안에서 질문을 받을 수 있도록 한정지어줘야한다.

그러면 어떻게 해야 잘 할 수 있을까?

구조를 만든다. (내가 먼저 판을 짜버린다)
- 여기서 물어봐주세요라고 하는 내용을 제외하고 싹 다 날려버려야한다.
- 필살기 2개 (필살기 : 유사경험 - 성공경험 - 인사이트)
```
1분 자기소개 양식 (워드기준) - 최대한 간결하게 무조건 외워라
첫 인사 (1줄) - 00에 지원하게된 000입니다. (미사여구, 별명 x / 이름 지원분야만 솔직하게)
필살기1 (2~3줄) - 직무 관련 경험 + 수치화 + How + Result + 배경내용
필살기2 (2~3줄)
지원동기 혹은 입사 후 포부 (1줄)
```
합격자의 67%는 How + Result가 존재한다.

합격자의 1분 자기소개 특징 1 : 수치화(합격자의 96%는 1분 자기소개에 수치화를 삽입)

합격자의 1분 자기소개 특징 2 : 두괄식(질문에 대한 답을 짧게 먼저하고, 그 뒤에 추가 설명) 

- 1분 자기소개는 자소서에 작성한 내용을 짧게 요약하는 것이다. 깔끔하게 두괄식으로 핵심을 전달하자!
- 첫 번째 필살기를 어떻게 던질 것인지가 중요하다!
- 내 필살기를 정확히 던져서 필살기에서 질문을 유도해라 ★★★★★

생각해 볼 질문들
1. 직무와 유사한 경험인가?
2. 회사 입사 후에도 적용가능한 성공경험인가?
3. How + Result + 필살기가 있는가? ★★★★★

수치화에 대해서 증명하라고 하는 면접관분들은 없다. 
그 당시 상황을 정확히 설명할 수 있는가를 알고자 하는 것
거짓말친다면 면접관분들이 던지는 질문에 대답 못할 것


면접복기는 항상 해야한다.
1. 1분자기소개와 연관되어서 어떤 질문을 받았는가?




## 📌 지원동기

- what? 우리 회사에 대한 이해 / 관심도 => 우리 회사에서 일하고 싶은 사람 회사 입장에서도 미래가치에 대한 투자를 하는셈
- why? 인재유출 막기 위해 / 신입은 다 해당, 경력은 핵심인재(상위20%) 유출방지
- how? 
```
매슬로우의 욕구 5단계
5단계 - 자아실현의 욕구 
4단계 - 존경의 욕구
3단계 - 소속의 욕구 (회사 성장, 경쟁력과 기술력들을 성장시키는데 기여하고 싶다) 
----------------------  이 위로 지원동기로 해라
2단계 - 안전의 욕구 (계약직, 프리랜서, 정규직) 이기적 지원동기
1단계 - 생리적 욕구 (연봉,복지) 이기적 지원동기
```
3년이상 경력직은 1,2단계를 말할 수 있다
경력직은 퇴직사유와 연결 시키는게 중요
 
이기적 지원동기(내가 좋자고 지원하는 것) / 이타적 지원동기(내가 지원해주는게 너희한데 좋아)

이타적 지원동기를 써야한다 반드시!

어떻게든 수치화해서 내가 너희 회사에 들어가는게 좋다를 어필해라

v 경쟁력 
- 그 회사는 어떤 경쟁력이 있는거냐?
- 내가 가고 싶을 만큼 매력적인 회사가 된거냐?

경쟁력 찾는 법?
- 경제 신문 스크랩 (내가 지원하고자 하는 기업의 경쟁력 요소를 찾는다)
- 현직자 인터뷰 (네트워크 등)
= 결론은 당신 회사의 경쟁력을 찾는 것, 내가 뭐 때문에 질문했다

<고리를 걸어라>
1. 기술적 특성 (이 회사만의 아이덴티티/ 차별화된 포인트 / 홈페이지참고 ) + 필살기 ★★★★★
2. 지역적 특성 (기여)
3. 고객에 대한 이해 (특정집단 고객과 접촉함 경험들을 통한 / 작더라도 성공경험)
4. 상품과 서비스에 대한 이해 (이 회사 제품을 사용했는데 경쟁사꺼까지 봤는데 이러한 부분이 좋다 그래서 나는 이 회사의 경쟁력을 정확히 이해하고 있다. 많이 써본사람 3c 개념을 가지고 이야기해야한다.)
5. 직무적 특성 / 문화적 강점 (현직자인터뷰, 알바)

자소서는 면접에서 나에게 유리한 질문을 끌어내는 것

회사명 검색 > 최신 산업 이슈들   
기술의 경쟁력은 회사의 지원동기 나온 배경은 산업의 트랜드

최근 이슈 뽑아내는 법
1. 트렌드가 될만한 키워드에서 뽑아라 (파란색)
2. 내가 지원하는 회사의 제품 혹은 서비스의 핵심 경쟁력을 규정
3. 경쟁사와 객관적인 수치를 비교해 볼 것 
4. 유튜브도 동원한다.(국내+해외 유튜버) 나의 느낀점을 이야기하면 끝

그대로 가져다 쓰는게 아닌 해석하는 과정이 필요하다. 나의견해 필살기를 연결시키면서 마무리






## 📌 면접 질문 준비 

참고 사이트 : https://www.457deep.com/62/?q=YToxOntzOjEyOiJrZXl3b3JkX3R5cGUiO3M6MzoiYWxsIjt9&bmode=view&idx=4307356&t=board

1. 자신의 직업관은?
직업 = 직종(직무분야) + 업종(산업분야)
직종 = 영업직,회계직,인사직,생산직
산업 = 제조업, 유통업, 금융업, 서비스업

1) 나의 강점과 재능과 부합하는 일을 하고 싶다는 것을 어필
내가 지원한 직무가 나의 강점, 재능에 어떻게 부합하는지

2) 나의 흥미와 관심이 부합하는 일을 하고 싶다는 것을 어필
내가 지원한 회사가 평소 나의 흥미, 관심과 어떻게 부합하는지 근거

3) 내가 지원한 회사에서 업무를 수행하는 것이 어떻게 국가와 지역사회에 공헌할 수 있는 지 설명

2. 왜 당신을 채용해야 하는가?
유사질문
- 타 지원자들보다 우월한 요소는 무엇인가?
질문의 의도
- 직무관련 지식 ,기술을 묻는게 아니다(그럴꺼면 시험을 봤을 것)
- 미처 면접관들이 알지 못한 지원자만의 특별한 character 알고 싶은 것
즉 지원자의 차별적인 요소를 스스로 어필할 수 있도록 기회 주는 것
- 지식이나 기술보다는 태도 관련 역량을 어필하는 것이 좋다.
ex) 감히 00부분에서 타 지원자보다 뛰어나다고 생각한다. 그에 따른 활동제시 성과 어필 그리고 이것을 직무에 어떻게 연결시키고 성과를 달성할 것인가를 제시

2-1. 우리 회사에 지원한 이유를 솔직하게 말해달라.
1) 연봉 / 복지가 좋은 회사
2) 쉽게 망하지 않는 우량한 회사
3) 이름 들으면 알 만한 회사
4) 나의 역량을 활용할 수 있는 회사
5) 사회와 국가에 도움이 될 수 있는 회사
6) 많이 배울 수 있는 회사
7) 조직문화가 합리적인 회사
8) 권한을 가지고 자신의 업무를 주도적으로 할 수 있는 회사
9) 저녁이 있는 회사

3. 공백기때 무엇을 하셨나요?
- 솔직함 + 목적성

4. 지방 근무는 가능한가요?
- 가능합니다. 저는 비록 수도권에 살고 있지만 다양한 활동을 하면서 타 지역에도 많이 가봤고 타 지역 출신의 친구들도 많이 만나 그 지역의 특성과 문화에 대해서도 잘 알고 있습니다.
또한 붙임성이 좋고 적응력이 빨라 금방 적응할 수 있습니다. 그래서 지방 근무를 하더라도 즐겁게 하겠습니다.

- 나는 지방근무보다 본사에서 근무하는 것이 회사가 나를 관리 활용하는 좋은 방법이라는 것을 어필할 수 있어야 한다.
1. 지방 근무를 해야 하는 상황이면 일단 따르겠다.
2. 하지만 나는 이런 직무에 대한 기술 역량을 가지고 있으며 이 곳에 근무할 때 나의 역량을 100% 발휘할 수 있으며 그것이 회사에 이득이 될 것이다. 만약 지방 근무를 하게 된다면 지방에서 충분히 배운 후 본사로 올라와 나의 역량을 발휘하겠다.

- 회사가 원하는 모범답안이 아닌 회사의 지침에 따르되 내가 지방근무보다는 거주지와 가까운 곳에서 근무하는 것이 회사에 도움이 된다는 것을 논리적인 근거를 들어 당당하게 설득하는 것이 좋은 답변이 된다.

5. 상사가 부당한 행위를 지시한다 어떻게 할 것인가?
전제조건깔자
1. 부당한 일 이라는 정의를 명확히 할 것
- 회사와 고객에게 피해가 갈 수 있는 도덕 윤리적인 척도에 맞지 않는 일
2. 나는 아직 회사생활에 서툴다는것을 인정
- 신입직원이기 때문에 용서받을 수 있는 상황들이 있다.

신입직원으로 부당한 일이라는 것을 정확하게 파악하기 어렵다.
하지만 내 생각과 다른 상사의 지시, 상사의 개인 심부름과 같이 회사와 고객에게 피해가 가지 않는 일, 도덕적 윤리적인 척도에 어긋나지 않는 일이면 업무를 수행하겠습니다.
상사님이 왜 이런 업무를 지시하셨는지 이해를 하고 제가 성장할 수 있는 발판으로 삼겠습니다. 
 중장기적인 관점에서 나의 역량을 쌓는데 도움이 될 수 있다.

하지만 도덕 윤리적으로 어긋나 고객과 회사에 피해가 갈 수 있는 일에 대해서는 업무 수행으로 인한 리스크들을 상사님과 부담없이 이야기 할 수 있는 기회를 활용하여 조심스럽게 말씀드리겠습니다. 조직성과에 보탬이 될 수 있는 최선의 대안책을 수행하겠습니다.
 

6. 다른 회사도 지원하고 있나?
의도
- 비록 우리 회사 지원자들은 타 회사에서도 탐을 낼 만큼의 유능한 인재이지만 다른 회사의 제안에 굴복하지 않고 우리 회사만을 위해 충성을 다할 수 있는 인재였으면 좋겠다는 생각

여기 회사만 지원했다고 하면 구라치는 놈이라는 인식과 함께 매력이 없는 사람으로 비춰짐

1) 자신이 지원한 회사의 개수를 10~20군데로 할 것
2) 서류전형 , 면접전형에서 탈락했다 (이유는 납득이 가도록)
3) 최종합격을 한 곳이 있다면 / 타 회사에 합격하기도 했으나 가지 않았다 (가지 않은 이유를 설득력있게 제시)
4) 이 곳에 합격하면 무조건 입사하여 나의 역량을 발휘하겠다.

7. 개인과 조직, 둘 중 어느 것이 더 중요한가?
1) 조직 자체의 특성
- 개인이 본연의 업무를 잘 수행해야 정교한 톱니바퀴처럼 차질 없이 돌아가게 된다. 물론 협업도 중요하다.
2) 시대적 특성
- 파레토 법칙 20:80 법칙
- 80% 결과는 20%의 원인에서 발생한다.
- 20% 인재가 80%의 결과를 만든다.

8. 연봉은 얼마나 받고 싶나?
1) 중견 중소기업인 경우 이러한 질문을 하는 의도
- 기업들은 비용을 절감하여 가격 경쟁력을 확보하려고한다.
 시장에서 생존하기 위해서는 인건비 절감은 불가피하다.
- 연봉 차이에서 오는 미스매치 예방 즉 이 놈이 연봉에 불만을 가지고 조기 퇴사할 놈인가 아닌가를 판단하는 것
- 회사 내에서도 직원 급여 테이블이 구축되어 있고 신입 연봉이 정해져 있기 때문에 지원자가 요구하는 연봉과 기업에서 책정한 연봉이 합의 가능한다면 협상을 통해 연봉을 정할 수 있어 미스매치를 예방할 수 있다.
내가 요구하는 금액과 회사에서 줄 수 있는 금액이 차이가 많이 난다면 협상의 여지도 없다.

2) 대기업 경우 이러한 질문을 하는 의도
- 지원자의 그릇과 패기를 파악하기 위함이다.
- 지원자의 역량을 현재가치, 미래가치로 환산하여 회사에 얼마나 수입을 가져다 줄 수 있는가를 파악.

9. 꿈과 비전이 무엇인가?

1) 개인적으로 이루고 싶은 꿈과 비전
2) 직업적으로 이루고 싶은 꿈과 비전
3) 사회적으로 이루고 싶은 꿈과 비전
실현 가능한 것, 회사에서 하는 업무와 유관한 것, 회사의 비전, 목표와 같은 방향인지, 지원자 본인의 생각과 철학이 녹아 있는것

10. 최근에 읽은 책은?

11. 상사가 이유없이 당신을 싫어한다면?
1) 지원자의 조직 적응에 대한 의지 파악
- 나만의 방식으로 회사 고유의 조직 문화에 적응하겠다.
2) 지원자의 문제해결능력
- 밝게 웃으며 인사하는 사람 싫어하지 않는다.
- 미운정 든다.
- 상대방과 친해지기 위해서는 공통점을 찾는다.
- 성실한 사람 싫어하지 않는다.

12. 야근 주말 근무 많은데 버틸 수 있겠나?
- 해야 할 일이 있는 경우에는 당연히 야근 주말근무를 통해 업무를 처리한다.
- 사내 비용절감을 통한 가격경쟁력 제고를 위해서는 야근을 많이 하지 않는 것이 회사에 유리하다.
3. 야근과 주말근무를 피하지는 않되, 회사 경쟁력 제고를 위해 최대한 효율적으로 업무를 처리하여 성과를 내겠다를 어필

13. 진상고객 대처 방법
- 회사가 제공할 수 있는 우수한 품질의 제품과 서비스를 제공했음에도 불구하고 그것을 가지고 문제 삼는 고객, 회사의 제품과 서비스에 벗어나는 것을 요구하는 고객

- 회사 업종 및 특성 , 지원 직무와 관련하여 발생할 수 있는 상황을 유형화 2~3 가지   유형별 대처방법을 간략하게 제시


- 진정성 있는 지원동기는 회사 분석에서 나온다.
- 지원동기는 회사의 중장기 전략을 말하라
    - "그걸 하기 위해 본인은 어떤 노력을 하셨죠?" 
- 지원동기를 달성하기 위한 본인의 노력이 있어야 한다.




## 📌 면접 질문 관련 기타

 

============= 자바 ====================

1. 자바의 특징 혹은 자바 언어의 장점

특징

- 이식성이 높은 언어(운영체제가 다르고, CPU가 달라도 같은 코드를 사용해 프로그램을 실행할 수 있다는 말)

- 객체 지향 언어

- 메모리를 자동으로 관리

- 함수적 스타일 코딩 또한 지원(람다식)

- 다양한 애플리케이션 개발에 용이

- 멀티쓰레드를 쉽게 구현 가능

- 동적로딩을 지원, 오픈 소스 라이브러리가 풍부

 

장점

- 간결하면서도 강력한 객체지향 언어이다.

- 개방형 구조로 여러 기술과 융합이 가능하다.

- 플랫폼에 독립적이므로, 여러 운영체제나 하드웨어에서도 동일하게 실행한다.

- 많은 오픈소스 프레임워크로 생산성을 증가하고 유지보수 비용을 절감할 수 있다.

 

2. 변수란 무엇이며, 변수의 종류는 어떠한 것이 있나

- 값을 저장할 수 있는 메모리 상의 공간을 의미

- int, string, char, boolean, double, long, byte, short

 

3. 변수의 명명 규칙, 자바의 네이밍 규칙

- 대소문자는 구분되며 길이의 제한은 없다

- 예약어 사용 불가

- 숫자로 시작하면 안된다.

- 특수문자는 _ 와 $ 만 허용한다.

- 파스칼 표기법과 카멜 표기법(최초에 사용된 단어를 제외한 첫번재 문자가 대문자이며 나머지는 소문자)을 사용한다.

 

4. 변수를 사용하는 목적이 무엇인가

- 코드의 재활용성과 가독성을 높여주고, 중복을 제거해서 유지보수를 용이하게 하기 위해 사용한다.

 

7. 객체 지향 언어란 무엇인가

- '객체'라는 개념을 기반으로 한 프로그래밍 패러다임중 하나이다.

 

8. 객체란 무엇인가

- 객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고

다른것과 식별 가능한 것을 말한다.

 

9. 객체지향의 3대 원칙(혹은 4대 원칙)

- S (Single responsibility Principle) 단일 책임 원칙

클래스와 메소드는 하나의 역할만 하도록 한다.

- O (Open Closed Principle) 계방 폐쇄 원칙

자신의 확장에는 개방돼 있고, 주변의 변화에 대해서는 폐쇄돼 있어야 하낟.

- L (Liskov Substitution Principle) 리스코브 치환 원칙

서브타입은 언제나 자신의 상위 타입으로 교체할 수 있어야 한다.

- I (Interface Segregation Principle) 인터페이스 분리의 원칙

클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.

- D (Dependency Inversion Principle) 의존 역전 원칙

자신보다 변하기 쉬운 것에 의존하지 마라.

 

10. 캡슐화란 무엇인가

- 중요한 데이터를 보존 보호하는 것

- 연관 있는 변수와 함수를 클래스로 묶는 작업

 

11. 상속이란 무엇인가

- 부모 클래스의 변수/메소드를 자식 클래스가 물려받아 그대로 사용 가능하게 하는 것

 

12. 다형성이란 무엇인가

- 하나의 객체가 여러 타입을 가질 수 있는 것

 

13. 추상화란 무엇인가.

- 공통된 행위나 필드를 모아서 클래스를 만드는 것

 

14. 클래스와 객체의 차이점은 무엇인가.

- 객체 : 소프트웨어 세계에 구현할 대상

- 클래스 : 객체를 구현하기 위한 틀, 연관되어 있는 변수아 메서드의 집합

 

15. 객체 지향 언어의 장점은 무엇인가

- 재사용성 : 상속을 통해 프로그래밍시 코드의 재사용을 높일 수 있다.

- 생산성 향상 : 잘 설계된 클래스를 만들어서 독립적인 객체를 사용함으로써 개발의 생산성을향상시킴.

- 자연적인 모델링 : 우리 일상생활의 모습의 구조가 객체에 자연스럽게 녹아들어 있기 때문에 생각하고

있는 것을 자연스럽게 구현할 수 있다.

- 유지보수의 우수성 : 프로그램 수정시 추가, 수정을 하더라고 캡슈로하를 통해 주변 영향이 적기 땜누에

유지보수가 쉬어서 매우 경제적이다.

 

16. 클래스에 사용 가능한 접근제한자와 키워드가 무엇이 있나

- public : package, class가 동일하지 않아도 모든 접근이 가능

- default : 동일 package에서만 접근을 허용, 접근 제한자 생략시 기본적으로 default 접근 제한자가 적용됨

 

17. 생성자에 사용 가능한 접근제한자와 키워드

- public : 모든 패키지에서 제한 없이 생성자 호출 가능

- protected : 같은 패키지에 속하는 클래스에서 생성자 호출 가능, 다른 패키지에 속한 클래스가

해당 자식 클래스라면 생성자를 호출할 수 있다.

- default : 생성자를 선언할 때 제한자를 아무것도 적지 않으면 default 접근 제한을 가진다.

같은 패키지 내에서 아무런 제한 없이 생성자 호출 가능

- private : 오로지 클래스 내부에서만 생성자 호출 가능, 객체 생성 가능

 

18. 필드에 사용 가능한 접근제한자와 키워드(의미 명확하게 알 것)

- public : 모든 패키지에서 제한 없이 생성자 호출 가능

- protected : 같은 패키지에 속하는 클래스에서 생성자 호출 가능, 다른 패키지에 속한 클래스가

해당 자식 클래스라면 생성자를 호출할 수 있다.

- default : 생성자를 선언할 때 제한자를 아무것도 적지 않으면 default 접근 제한을 가진다.

같은 패키지 내에서 아무런 제한 없이 생성자 호출 가능

- private : 오로지 클래스 내부에서만 생성자 호출 가능, 객체 생성 가능

 

19. 메소드에 사용 가능한 접근제한자와 키워드

- public : 모든 패키지에서 제한 없이 생성자 호출 가능

- protected : 같은 패키지에 속하는 클래스에서 생성자 호출 가능, 다른 패키지에 속한 클래스가

해당 자식 클래스라면 생성자를 호출할 수 있다.

- default : 생성자를 선언할 때 제한자를 아무것도 적지 않으면 default 접근 제한을 가진다.

같은 패키지 내에서 아무런 제한 없이 생성자 호출 가능

- private : 오로지 클래스 내부에서만 생성자 호출 가능, 객체 생성 가능

 

20. final 키워드의 사용 가능 위치와 그 의미에 대해 설명

final 변수

- 상수라고도 불린다

- 변수를 선언함과 동시에 초기화하며 이후에 값을 수정할 수 없다.

- 오직 get만 가능하다.

final 메소드

- 오버라이딩(Overriding)이 불가능하다.

- 상속 받은 그대로 사용해야 한다.

final 클래스

- 상속(Inheritance)이 불가능하다.

- subclass를 만들 수 없다.

 

21. 오버로딩이 무엇인가

같은 이름의 함수(메서드)를 여러개 정의하고, 매개변수의 유형과 개수를 다르게 하여 다양한 유형의 호출에 응답할 수 있게 하는것

 

22. 오버로딩의 성립 요건이 무엇인가

1. 메서드 이름이 같아야 한다.

2. 매개 변수의 개수 또는 타입이 달라야 한다.

3. 매개 변수는 같고 리턴 타입이 다른 경우는 오버로딩이 성립되지 않는다.

4. 오버로딩된 메서드들은 매개 변수에 의해서만 구별될 수 있다.

 

23. 오버라이딩이 무엇인가

부모 클래스로부터 상속받은 메서드의 내용을 변경하는것

 

24. 오버라이딩과 성립 요건이 무엇인가

1. 이름이 같아야 한다.

2. 매개변수가 같아야 한다.

3. 리턴 타입이 같아야 한다.

 

25. 오버로딩과 오버라이딩의 차이에 대해 전체적으로 설명

오버로딩 : 같은 이름의 메서드를 여러 개 가지면서 매개 변수를 다르게 정의하는 것

오버라이딩 : 상위 클래스(부모 클래스)가 갖고 있는 메소드(자식 클래스)를 하위 클래스에서 재정의해 사용하는것

 

26. 변수의 선언 위치에 따른 변수 종류와 메모리 할당 위치

- 클래스 변수 : 클래스 영역, 클래스가 메모리에 올라갈 때

- 인스턴스 변수 : 클래스 변수, 인스턴스가 생성될 때

- 지역 변수 : 클래스 이외의 영역(메서드, 생성자, 초기화블럭), 변수 선언문이 수행되었을 때

 

27. static 키워드의 의미와 라이프사이클

(간혹 static과 void의 차이를 물어본다. 연관은 없지만 각각 알고 있다면 답변할 수 있다)

- 정적 변수를 선언하기 위해서 사용하는 키워드

- 프로그램의 생성과 함께 할당되고 프로그램의 종료시에 해제 된다.

void : return값이 없는 메서드

 

29. return이란?

- 값을 반환하는 동작을 한다.

- 메서드를 중단시키는 역할도 한다. return이 처음 등장한 이후의 구문은 실행되지 않는다.

 

30. 매개변수와 인자의 차이

인자 : apthem 호출시에 전달되는 값

매개변수 : 메소드에서 전달 받은 값

 

31. 자바에서 메소드의 호출 방식과 자료구조, 해당 자료구조의 특징

Call by calue(값에 의한 호출)

- 메소드로 인자값을 넘길 때, 그 값을 복사하여 넘기기 때문에 메소드 내에서는 복사된 값으로 작업을 하고, 원래의 값을 변경시키지 않는다.

 

자료구조

List

원하는 순서로 Element삽입가능, 각 요소는 Index 번호를 부여 받는다.

- ArrayList : 중복 Yes, 순서 Yes, 정렬 No, THREAD-SAFE No

- LinkedList : 중복 Yes, 순서 Yes, 정렬 No, THREAD-SAFE No

- Vector : 중복 Yes, 순서 Yes, 정렬 No, THREAD-SAFE Yes

 

SET

중복 Element불가능, 그러므로 쉽게 중복여부 확인 가능, 특정 순서(Order)정할 수 없음

- HashSet : 중복 No, 순서 No, 정렬 No, THREAD-SAFE No

- LinkedHashSet : 중복 No, 순서 Yes, 정렬 No, THREAD-SAFE No

- TreeSet : 중복 No, 순서 Yes, 정렬 Yes, THREAD-SAFE No

 

MAP

Key/Value로 구성된다. Key 중복 허용X, value 중복 허용O

- HashMap : 중복 No, 순서 No, 정렬 Yes(Key), THREAD-SAFE No, null key/value 허용

- LinkedHashMap : 중복 No, 순서 Yes, 정렬 No(Key는 삽입한 순서대로 정렬), THREAD-SAFE No

- Hashtable : 중복 No, 순서 No, 정렬 No, THREAD-SAFE Yes

- TreeMap : 중복 No, 순서 Yes, 정렬 Yes, THREAD-SAFE No

 

Queue

먼저 들어온 데이터가 먼저 나가는 구조

Output으로 나올 Element만 기본적으로 접근 가능하다.

1. 큐는 한쪽 끝은 프런트(fornt)로 정하여 삭제 연산만 수행함

2. 다른 한쪽 긑은 리어(rear)로 정하여 삽입 연산만 수행함

3. 예시) 컴퓨터 버퍼에서 사용/마구 입력됐으나 처리를 못할 때, 버퍼(큐)를 만들어 대기 시킴

 

PriorityQueue

일반적인 큐의 구조 FIFO(First In First Out)과 다른, 우선순위를 먼저 결정하고 그 우선순위가 높은 데이터가 먼저 나가는 자료구조

1. 내부 요소는 힙으로 구성되어 있다.

2. 우선순위 큐에 저장할 객체를 필수적으로 Comparable Interface를 구현해야 한다. 구현 후 compareTo 메소드를 override 하게 되고 해당 객체에서 처리할 우선순위 조건을 리턴해주면 PriorityQueue가 알아서 우선순위가 높은 객체를 추출해준다.

 

Deque

큐의 양쪽에서 데이터를 삽입과 삭제를 할 수 있는 자료구조를 의미한다.

1. 어느 쪽에서 입력하고 어떤 쪽에서 출력하느냐에 따라서 스택(Stack)으로 활용할수도 있고, 큐(Queue)로도 활용할 수 있다.

2. Null요소는 사용 불가

 

32. package란 무엇인가

클래스들의 모음집

 

33. import란 무엇인가

다른 패키지 안의 클래스를 사용하기 위해 클래스 이름 앞에 붙이는 것

 

34. 상속을 사용하는 목적이 무엇인가.

연관된 일련의 클래스에 대한 ‘공통적인 규약을 정의하고 적용하는 것’

 

35. 상속의 장점

1. 기존에 작성된 클래스를 재활용 가능ㄴ

2. 자식 클래스 설계 시 중복되는 맴버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 맴버를 작성하지 않아도 됨

3. 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련

 

36. 상속의 특징

- 부모 클래스 > Super class, 자식 클래스 > Sub class

- 자바는 다중 상속을 지원하지 않는다. extends뒤에는 하나의 부모 클래스만 올 수 있다.

- 상속 횟수에 제한이 없다.

- 자바의 최상위 클래스는 Object이다. 즉 자바의 모든 클래스는 Object의 자손

 

 

37. 다형성의 장점

하나의 배열로 여러 종류의 객체를 다룰 수 있다.

각각의 타입을 ᄄᆞ로 정의하지 않아도 되므로 코드양이 그만큼 줄어든다.

 

38. 동적바인딩이란

프로그램이 실행되어야 메모리에 크기가 얼마만큼 할당되는지 알 수 있게 되는 것을 의미

 

39. 동적바인딩 성립 요건

상속 관계로 이루어져 다형성이 적용된 경우에, 메소드 오버라이딩이 되어 있으면 정적으로 바인딩 된 메소드 코드보다 오버라이딩 된 메소드 코드를 우선적으로 수행하게 된다.

 

40. 추상클래스란 무엇인가

클래스들의 공통되는 필드와 메소드를 정의한 클래스

 

41. 추상클래스의 특징

1. 클래스 앞에 abstract 키워드를 이용해서 정의한다.

2. 미완성의 추상 메소드를 포함할 수 있다.

3. 자체적으로 객체를 생성할 수 없다. 따라서 상속을 통해 자식 클래스에서 인스턴스를 생성해야 한다.

4. 일반적인 상속의 특성과 동일하다.

 

42. 추상클래스의 사용 목적

상속을 강제하기 위해 사용한다. 즉 부모 클래스에는 메소드의 시그니처만 정의해놓고 그 메소드의 실제 동작 방법은 이 메소드를 상속받은 하위 클래스의 책임으로 위임하고 있다.

 

43. 추상클래스의 장점

- 추상 클래스에서 설계가 완료되면 자식 클래스에서 상속을 받아서 기능을 확장하는데 용이

- 자식 클래스에서 추상 메소드의 구현을 강요하기 때문에 표준화 정도를 높임

- 클래스들의 공통 사항을 한 곳에서 관리할 수 있기 때문에 개발 및 유지보수가 편리해짐

 

44. 인터페이스란 무엇인가

자바 프로그래밍 언어에서 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상 자료형이다.

 

42. 인터페이스의 특징

1. 추상 메소드만 정의 가능

2. 일반 클래스는 여러 interface를 다중 상속할 수 있다.

3. 인터페이스간의 상속에서는 다중상속이 제공된다.

4. 상속을 받은 일반 클래스는 interface의 추상 메소드를 모두 재정의 해야 한다.

 

 

43. 인터페이스의 사용 목적

공동 작업시 충돌을 방지하기 위해서

 

44. 인터페이스의 장점

1. 개발 시간을 단축 시킬 수 있다.

- 인터페이스를 사용하면 다른 개발자들이 각각의 부분을 완성할 때 까지 기다리지 않고 서로 규약만 정해두어 각자의 부분만 따로 나눠서 작성된 코드를 컴파일 할 수 있다.

2. 클래스 간 결합도를 낮출 수 있다.

- 코드의 종속성을 줄이고 유지보수성을 높이도록 해준다.

3. 표준화가 가능하다.

- 클래스의 기본틀을 제공하여 개발자들에게 정형화된 개발을 제시할 수 있다.

 

45. 추상클래스와 인터페이스 정리

공통점 : 추상 메소드를 사용한다. 객체 생성이 불가능하다.(상속받은 자식에서만 객체를 생성하여 사용가능하다.)

차이점

- 추상클래스 : 추상메소드의 부분적인 작성이 가능, 변수 선언가능, 다중상속 불가, abstract, extends 키워드 사용

- 인터페이스 : 추상메소드의 선언만 가능, 상수만 선언가능, 다중상속 가능, interface, implements 키워드 사용

 

46. String과 StringBuilder의 차이점

String클래스는 조회가 많은 환경에서 성능적으로 유리하며, StringBuffer&StringBuilder 클래스는 문자열 연산이 자주 발생할 때 문자열이 변경가능할 객체기 때문에 성능적으로 유리하다.

 

47. StringBuffer와 StringBuilder의 차이점

StringBuffer와 StringBuilder의 차이점은 동기화 지원의 유무이고 동기화를 고려하지 않는 환경에서 StringBuilder가 성능이 더 좋고, 동기화가 필요한 멀티쓰레드 환경에서는 StringBuffer를 사용하는 것이 유리하다.

 

48. Wrapper클래스란?

기본 자료타입을 객체로 다루기 위해서 사용하는 클래스

 

49. autoboxing과 autounboxing에 대해

- 오토박싱(AutoBoxing) : JDK 1.5 이상에서는 기본 타입의 데이터를 객체 타입의 데이터에 할다앟면 기본타입의 데이터가 객체 타입의 데이터로 자동으로 형변환이 되면수 참조 변수에 할당한다.

- 오토언박싱(AutoUnBoxing) : 오토박싱과 반대로 객체 타입의 데이터를 기본 타입의 변수에 할당하면 자동으로 형변환이된다.

 

50. String을 기본자료형으로 바꾸는 방법

'원하는 자료형의 래퍼클래스명.parse'원하는 자료형의 래퍼클래스명(“원하는 텍스트”)‘

ex) int A = Integer.parseInt("100");

 

51. 기본자료형을 문자열로 바꾸는 방법

String.valueOf(변수명)

 

52. java.util.Date, java.sql.Date, Calendar, GregorianCalendar 다루는거 익숙해지게 연습좀 해두기! 코딩테스트에 자주 나온다..

 

53. 예외처리를 하는 목적

프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지하기 위해

 

54. 대표적인 RuntimeException 5가지와 핸들링 방법(면접에서 어떤 에러를 경험해봤고 어떻게 해결했는지를 물어볼때가 있다.)

1. ArithmeticException : 정수를 0으로 나누었을 경우

2. ArrayStoreException : 배열 유형이 허락하지 않는 객체를 객체 배열에 젖아하려는 경우

3. ArrayIndexOutOfBoundsException : 배열을 찹조하는 인덱스가 잘못된 경우

4. ClassCastException : 적절치 못하게 Class를 형 변환하는 경우

5. NullPointerException : 널(null)객체를 참조했을 경우

 

핸들링 방법

1. try, catch block

2. throws

4. throw(인위적 Exception 발생)

 

55. 예외처리를 하는 방법

try, catch, throw, throws, finally

 

56. 사용해본 Stream 종류에 대해 설명하세요

- InputStream : 문자/바이트 입력 스트림을 위한 추상클래스

- OutputStream : 문자 출력 스트림을 위한 추상클래스

- FileInputStream : 파일에서 바이트를 읽어들여 문자/바이트 스트림으로 변환

- FileOutputStream : 문자/바이트 스트림을 바이트 파일로 변환

 

57. 자료구조를 사용하는 이유

데이터를 사용하는데 있어 효율성을 높이기 위해

 

58. List계열과 Set 계열의 특징

List : 순서가 있는 데이터의 집합, 데이터의 중복을 허용함

Set : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음

 

59. Map 계열의 특징

키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합. 순서는 유지되지 않고, 키는 중복을 허용하지 않으며 값의 중복을 허용함.

 

60. Vector란?

저장순서를 유지하며 중복을 허용한다. 멀티쓰레드에 대한 동기화가 되어 있다.

 

61. tree구조와 stack, queue 자료 구조에 대해

tree : 계층적 자료구조로 루트라는 노드가 있고 각 연결된 노드는 부모-자식 관계이며 노드간 사이클이 존재하지 않는 자료구조

stack : 입력된 데이터는 중복될 수 있으며 나중에 들어간 것이 먼저 나오는 후입 선출 자료구조이다.

queue : 입려된 데이터는 중복될 수 있으며 먼저 들어간 것이 먼먼저 나오는 선입선출 자료구조이다.

 

62. 제네릭스를 사용하는 이유

1. 컴파일 시 강한 타입 체크를 해서 에러를 사전에 방지하기 위해

2. 타입 변환을 제거해서 프로그램 성능을 향상시키기 위해

 

63. 제네릭스를 사용하면 좋은점

1. 컴파일 타임에 타입을 체크하기 때문에 객체 자체의 타입 안전성을 높인다.

2. 형 변환의 번거로움을 줄일 수 있다.

 

64. 프로세스란 무엇인가

실행중인 프로그램

 

65. 스레드란 무엇인가

프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다. 또한 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스 라고 한다.

 

66. 스레드와 프로세스의 차이

프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위이다.

 

67. 멀티스레드와 멀티 프로세스에 대해 설명

멀티 프로세스

- 두 개 이상 다수의 프로세서(CPU)가 협력적으로 하나 이상의 작업(Task)을 동시에 처리하는것

- 각 프로세스간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용한다.

멀티 스레드

- 하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것이다.

 

68. 스레드의 장단점

장점

- 빠른 프로세스 생성

- 적은 메모리 사용

- 쉬운 정보 공유

단점

- 교착상태에 빠질 수 있다.

 

69. 스레드를 구현하는 방법

1. Thread 클래스를 상속 받는다.

2. Runnable 인터페이스를 구현한다.

 

70. 동기화처리란

여러 개의 스레드가 한 개의 자원을 사용하고자 할 때 해당 스레드만 제외하고 나머지는 접근을 못하도록 막는 것

 

71. 동기화처리를 하는 방법

1. synchronized를 이용한 동기화

2. wait(), notify()를 이용한 동기화

 

72. 데몬스레드란

주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드

 

73. 서버와 클라이언트에 대해 설명하세요

클라이언트 : 서비스를 사용하는 사용자

서버 : 클라이언트에게 네트워크를 통해 서비스를 제공하는 시스템

 

74. 소켓 프로그래밍이란

프로세스간의 통신에 사용되는 양쪽 끝단을 이용한 통신 프로그래밍이다.

 

75. TCP와 UDP

 

TCP

연결 방식

- 연결 기반(connection-oriented)

- 연결 후 통신(전화기)

- 1:1 통신방식

 

특징

- 데이터의 경계를 구분안함(byte-stream)

- 신뢰성 있는 데이터 전송

- 데이터의 전송순서가 보장됨

- 데이터의 수신여부를 확인함(데이터가 손실되면 재전송됨)

- 패킷을 관리할 필요가 없음

- UDP보다 전송속도가 느림

관련 클래스

- Socket

- ServerSocket

 

UDP

연결방식

- 비연결기반(connectionless-oriented)

- 연결없이 통신(소포)

- 1:1, 1:n, n:n 통신방식

특징

- 데이터의 결계를 구분함(datagram)

- 신뢰성 없는 데이터 전송

- 데이터의 전송순서가 바뀔 수 있음

- 데이터의 수신여부를 확인안함(데이터가 손실되어도 알 수 없음)

- 패킷을 관리해줘야 함

- TCP보다 전송속도가 빠름

관련 클래스

- DatagramSocket

- DatagramPacket

- MulticastSocket

 

-------------- 여기서부터 DB ---------------

 

1. DML의 종류

SELECT, INSERT, UPDATE, DELETE

 

2. DDL의 종류

CREATE, DROP, ALTER, TRUNCATE

 

3. SELECT구문 수행 순서

FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY

 

4. 조인이란

두 개 이상의 테이블을 서로 연결하여 데이터를 검색할 때 사용하는 방법

5. 조인을 왜 사용하나

여러 테이블의 데이터를 조합하여 처리하기 위해

 

6. inner join과 outer join

inner join : 조인이 되는 킷값을 기준으로 교집합

outer join : 정상적으로 조인 조건을 만족하지 못하는 행들을 보기 위해 사용된다. 즉 어ᄄᅠᆫ 집합을 기분으로 해서 조인되는 다른 집합과의 연결에 실패했더라도 그 결과를 추출하는 조인을 말한다.

 

7. equal join과 non-equal join

EQUI JOIN : 조인 조건식에 ‘=’을 사용한다.

NON-EQUI JOIN : '='연산자 이외의 비교 연산자를 사용하는 것

 

8. outer join의 종류

1. LEFT OUTER JOIN

2. RIGHT OUTER JOIN

3. FULL OUTER JOIN

 

9. natural join이란

두 테이블 간의 동일한 이름을 갖는 모든 컬럼들에 대해 등가조인(EQUI JOIN)을 수행한다.

 

10. self조인이란

하나의 테이블 내에서 같은 테이블의 다른 컬럼 값을 참조하고 있을 때 이를 셀프 조인을 활용하여 원하는 데이터를 얻게 해주는 역할

 

11. self조인 사용 이유

자신의 테이블을 참조하기 위해서

 

12. 유니온과 조인의 차이점

UNION : 합집합. 중복을 제거하지 않는다.

JOIN : 교집합. 중복을 제거한다.

 

13. subquery란

SELECT문 안에 또다시 SELECT문이 있는 쿼리문이ᅟᅡᆮ.

 

14. 기본 select부터 join, subquery를 이용한 select구문 작성하는 것은 손코딩(A4용지에 펜으로 작성)할 수 있게 연습할 것

 

15. 오라클에서 사용해본 객체 종류

TABLE : 데이터 담고 있는 객체

VIEW : 하나 이상의 테이블 연결해서 마치 테이블인 것처럼 사용하는 객체

INDEX : 테이블에 있는 데이터를 바르게 찾기 위한 객체

SYNONYM : 데이터베이스 객체에 대한 별칭을 부여한 객체

SEQUENCE : 일련번호 채번을 할 때 사용되는 객체

FUNCTION : 특정 연산을 하고 값을 반환하는 객체

PROCEDURE : 함수와 비슷하지만 값을 반환하지 않는 객체

PACKAGE : 용도에 맞게 함수나 프로시저 하나로 묶어 놓은 객체

 

16 제약조건이란 무엇인가

테이블에 부적절한 자료가 입력되는 것을 방지하기 위해서 여러 가지 규칙을 적용해 놓는 것

 

17. 제약조건의 사용 이유

데이터베이스 데이터의 정확성을 유지하기 위한 목적

 

18. 제약조건의 종류 및 간단한 설명

1. NOT NULL : 해당 컬럼에 NULL값이 들어오지 못하게 함

2. UNIQUE : NULL은 허용하나 중복은 불가능함

3. PRIMARY KEY : NULL, 중복 불가능

4. FOREIGN KEY : 참조하는 테이블 칼럼의 데이터만을 허용

5. CHECK : 데이터의 값의 범위나 조건을 설정하여 조건에 해당되는 데이터만 허용

6. DEFAULT : 아무런 데이터를 입력하지 않았을 경우 지정한 데이터가 자동으로 입력

 

19. 테이블에 왜 primary key를 설정하는지

일관성 없는 데이터가 반복적으로 쌓이는 것을 방지하기 위해

 

20. foreign key 제약조건은 무엇이며 왜 사용하는지

FOREIGN KEY : 참조하는 테이블 칼럼의 데이터만을 허용

중복된 데이터가 없으면서도 문제없이 데이터를 저장, 관리하기 위해

 

21. 트랜젝션이란 <-- 이거 정말 중요

데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

 

22. 트랜젝션과 쓰레드의 차이 <-- 쌩뚱맞게 전혀 연관 없는 질문도 간혹 나오는데, 명확히 알고 있으면 충분히 답변 가능

쓰레드 : 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다. 또한 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스 라고 한다.

트랜젝션 : 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

 

 

23. view란 무엇인가

하나 이상의 테이블이나 다른 뷰의 데이터를 볼 수 있게 하는 데이터베이스 객체이다.

 

24. view를 사용하는 목적

보안 강화와 QUERY 단순화를 위해

 

25. index란 무엇인가

데이터베이스 테이블에 잇는 데이터르 ㄹᄈᆞᆯ리 찾기 위한 용도의 데이터베이스 객체

 

26. index의 장점과 단점

장점 : 검색과 정렬 속도를 향상시킨다.

단점 : DB변경작업이 잦으면 성능이 저하된다.

 

27. index의 종류

1. B-TREE 인덱스 : 실시간으로 데이터 입력과 수정이 일어나는 환경에 많이 사용함

2. BITMAP 인데스 : 데이터 값의 종류가 적고 동일한 데이터가 많을 경우에 많이 사용함

 

28. 프로시져란, 함수란, 패키지란 <- 이거 세개 묶어서 공부하기

프로시저 : 특정 작업을 수행 하는, 이름이 있는 PL/SQL BLOCK이다. 필요할 때마다 호출, 사용하여 작업 효율을 늘릴 수 있다.

함수 : 호출 시 FUNCTION 내에 작성한 쿼리를 수행해서 특정 값을 반환하는데 사용

패키지 : 변수, 상수, 서브프로그램드으이 항목을 묶어놓은 객체

 

29. 트리거란

특정 테이블에 DML문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램

 

----------------- 화면 내용 ------------------

 

1. javascript와 jquery 차이

자바스크립트 : javaScript는 Netscape.inc가 개발한 스크립팅 언어이다. 상소 작용 효과를 생성하고 다양하나 검증 작업과 관련하여 HTML페이지에 임베드 할 수 잇는 마이크로 시스템.

제이쿼리 : jQuery는 HTML의 클라이언트 측 스크립팅을 단순화 하는 javaScript의 경량 크로스 브라우저 라이브러리입니다.

 

2. jquery의 장점

- 자바스크립트보다 훨씬 간단하게 사용 가능하면서도 동일한 동작을 구현할 수 있다.

- 이벤트, 애니메이션, ajax등을 활용할 때 유용하다.

- 멀티 브라우저 지원이 된다. 어느 브라우저에서나 동일하게 작동한다.

 

 

------------ 서블릿jsp ----------------------

 

1. 클라이언트와 서버에 대해 설명하시오

클라이언트 : 다른 프로그램에게 서비스를 요청하는 프로그램

서버 : 그 요청에 대해 응답을 해주는 프로그램

 

2. web 서버와 was 서버의 차이

web서버 : 클라이언트가 서버에 페이지 요청을 하면 요청을 받아 정적 컨텐츠(html, png, css등)을 제공하는 서버

was서버 : db조회나, 어떤 로직을 처리해야 하는 동적인 컨텐츠를 제공하는 서버

 

3. 서블릿 컨테이너와 jsp 컨테이너의 역할

서블릿 컨테이너 : 클라이언트 요청에 따라 서블릿을 수행하는 프로그램

JSP 컨테이너 : JSP 컨테이너는 JSP를 서블릿으로 변환하는 프로그램

 

4. web서버와 was서버의 장단점

 

web서버

장점

- 속도가 빠르다.(대신 파일의 양이 많으면 많아질수록 웹 페이지로 가공할 양이 늘어나니 느려진다.)

- 구축 비용이 적다.(별도의 DB, 비즈니스 로직이 필요없기 때문이다.)

단점

- 정해진 데이터만 웹 페이지에 출력한다.

- 관리가 힘들다. 코드 하나하나 수정해야 한다.

 

was서버

장점

- 다양한 정보를 제공할 수 있다.

- 유지보수가 쉽다.

단점

- 상대적으로 느리다.

- 추가 비용이 발생한다. 웹 서버 이외에 was를 사용해야 하기 때문에!

 

5. 서블릿이란?

클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 규현 규칙을 지킨 자바 웹 프로그래밍 기술

 

6. 서블릿 설계 규약(여유 되시면 추가로 보기!)

1. public 클래스로 작성하기

2. HttpServlet 상속하기

3. doGet, doPost 등의 메서드 오버라이딩하기

4. web.xml에 서블릿 등록하기

 

7. 서블릿의 동작 구조

1. 클라이언트의 URL요청

2. HTTP요청을 처리하기 위한 HttpServletRequest 객체 및 HttpServletResponse 객체 생성

3. 요청된 URL을 배포서술자(DD, Deplyment Descriptor)분석을 통해 요청된 서블릿 클래스를 찾음

4.. 서블릿 컨테이너에서 실행된 적 or 메모리에 생성된 인스턴스가 있는지 체크

- 처음 실행 : 인스턴스를 생성한 후 init()호출 -> 초기화 후 스레드 생성

- 이미 실행 : 기존 인스턴스에 스레드 생성

5. 각 스레드의 service()호출 및 Get or Post방식에 따라 doGet() or doPost() 호출

- 2에서 생성된 HttpServletRequest 객체와 HttpServletResponse 객체가 인자로 전달됨

6. doGet() or doPost() 로직에서 생성된 동적 웹 페이지 결과물은 HttpServletResponse 객체에 담김.

7. HttpServletResponse 객체를 서블릿 컨테이너에서 HTTP 형태로 바뀌어 웹 서버로 전송

8. HttpServletRequest 객체와 HttpServletResponse 객체의 메모리 소멸 및 스레드 종료

 

8. web.xml 배포서술자란 무엇인가

배포 서술자(DD, Deployment Descriptor)는 Java EE 스펙으로 웹 애플리케이션의 기본적인 설정을 위해 작성하는 파일로, 보통은 WEB-INF/web.xml파일을 말한다.

 

9. 배포서술자에 작성하는 내용이 무엇인가

1. ServletContext의 초기 파라미터

2. Session의 유효시간 설정

3. Servlet/JSP에 대한 정의

4. Servlet/JSP 매핑

5. Mime Type 매핑

6. Welcome File list

7. Error Pages 처리

8. 리스너/필터 설정

9. 보안

 

10. 서블릿의 라이프사이클 - 7번 참조

 

11. get과 post의 차이

- GET은 URL에 데이터가 노출되나 POST는 노출되지 않는다.

- GET은 데이터의 위치가 Header이고, POST는 Body이다.

- GET은 캐싱이 가능하나, POST는 불가능하다.

 

 

12. forward와 sendRedirec 차이

Forward : client가 웹 브라우저에서 요청 시 Forward는 client에게 보여지지 않는 페이지에서 작업을 하게 된다. 그러므로 client는 페이지의 이동을 모르게 되며, URL또한 변경이 되지 않는다. Client가 요청을 하게 될 때 생성되는 객체는 계속 사용이 가능하며 다른 페이지 에서도 그 객체를 사용할 수 있다.

Redirect : client가 웹브라우저에서 요청시 Redirect는 client에게 페이지의 이동을 모두 노출시킨다. client가 요청 시 새로운 객체를 생성하며 기존의 객체는 사라지게 되며, UR:이 페이지 이동시마다 변경된다. 이전의 전송값을 이동한 페이지에서 사용 불가능하다.

 

13. 필터란

Client로부터 Server로 요청이 들어오기 전에 서블릿을 거쳐서 필터링 하는 것

 

14. 래퍼란

웹 브라우저와 웹 컴포넌트 사이를 오가는 데이터에 변형을 가하려면 필터 클래스와 더불어 포장하는 역할을 하는 클래스를 작성해야 하는데 이것이 래퍼 클래스이다.

 

15. session 과 cookie에 대해 간략하게 정리해두세요

cookie : 클라이언트 로컬에 저장되는 키와 값이 들어잇는 작은 데이터 파일

session : 서버에 클라이언트의 상태 정보를 저장하는 기술로 논리적인 연결을 세션이라고 한다.

 

16. 세션과 쿠키의 차이도 함께 봐주세요

- 저장 위치 : 쿠키는 클라이언트(=접속자pc)에 저장되며 세션은 웹 서버에 저장된다.

- 저장 형식 : 쿠키는 text로 저장되며 세션은 Object로 저장된다.

- 만료 시점 : 쿠키는 쿠키 저장시 시 설정되며 세션은 브라우저 종료시 삭제된다.

- 사용하는 자원 : 쿠키는 클라이언트 리소스를 사용하며 세션은 웹 서버 리소스를 사용한다.

- 용량 제한 : 쿠키는 총 300개, 하나의 도메인당 20개, 하나의 쿠키당4kb. 세션은 서버가 허용하는 한 용량제한이 없다.

- 속도 : 쿠키가 세션보다 ᄈᆞ르다.

- 보안 : 쿠키가 세션보다 안좋다.

 

17. jsp란

HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구이다.

 

18. 서블릿과 jsp의 차이

Servlet

- 자바코드로 구현하고 컴파일하고 배포해야 한다.

- HTML태그로 문자열(“”)스크림으로 처리해야 한다.

- 코드가 수정되면 다시 컴파일하고 배포해야 한다.

JSP

- 키워드가 태그화 되어 서블릿에 비해 배우기 쉽다.

- 자바코드를 <% %>태그 안에 처리해주어야 한다.

- HTML처럼 태그를 사용하여 자바코드도 사용이 가능하다.

 

19. jsp의 특징

- 동적 웹 어플리케이션 컴포넌트이다.

- 확장자는 .jsp

- 클라이언트의 요청에 동적으로 작동하고, 응답은 html을 이용한다.

- jsp는 서블릿으로 변환되어 실행된다.(컴파일러가 알아서 변환해준다.)

- MVC패턴에서 View로 이용된다.

 

20. jsp tag element 5가지

1. 지시자 <%@ %> : 페이지 속성 지정

2. 주석 <%-- --%> : 주석 처리

3. 선언 <%! %> : 변수, 메소드의 선언

4. 표현식 <%= %> : 결과값 출력

5. 스크립트릿 : <% %> JAVA코드 삽입

 

21. jsp 내장객체란

JSP내에서 선언하지 않고 사용하는 객체

 

22. jsp 내장객체 9가지

1. request : javax.servlet.http.HttpServletRequest / HTML 폼 요소의 선택 값 등 사용자 입력 정보를 읽으려고 사용한다.

2. response : javax.servlet.http.HttpServletResponse / 사용자 요청에 대한 응답을 처리하려고 사용한다.

3. pageContext : java.servlet.jsp.PageContext / 현재 JSP 실행에 대한 context 정보를 참조하려고 사용한다.

4. session : javax.servlet.http.HttpSession / 클라이언트의 세션 정보를 처리하려고 사용한다.

5. application : javax.servlet.ServletContext / 웹 서버의 애플리케이션 처리와 관련된 정보를 참조하려고 사용한다.

6. out : javax.servlet.jsp.JspWriter / 사용자에게 전달하기 위한 output 스트림을 처리하려고 사용한다.

7. config : javax.servlet.servletConfig / 현재 JSP 의 초기화 환경을 처리하려고 사용한다.

8. page : java.lang.Object / 현재 JSP 의 클래스 정보를 보려고 사용한다.

9. exception : java.lang.Throwable / 예외 처리를 하려고 사용한다.

 

23. jsp 내장 객체의 영역 구분하여 설명 -- 22번 참조

 

24. el로 값을 바로 출력하지 않고 jstl c:out을 이용해야 하는 이유

1. html이나 스크립트가 실행되어 위험하다.

2. 엄격한 태그 규칙을 위해 사용

3. 개행문자 파싱의 차이 때문에 사용

4. 보안성 때문에 사용

 

 

----------------- ajax -------------------

 

1. ajax란 무엇인가

JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML로 데이터를 주고받는 기술

 

2. 동기 방식과 비동기 방식의 차이점

동기 방식

- 요청을 보낸 후 응답(=결과)를 받아야지만 다음 동작이 이루어지는 방식

- 어떠한 일을 처리할 동안 다른 프로그램은 정지한다.

- 실제 cpu가 느려지는 것은 아니지만 시스템의 전체적인 효울이 저하된다고 할 수 있다.

비동기 방식

- 요청을 보낸 후 응답(=결과)와는 상관없이 다음방식이 작동하는 방식

- 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 수행함으로 효율적이다.

 

3. ajax의 장단점

장점

- 웹 페이지의 속도 향상

- 서버의 처리가 완료 될 때까지 기다리지 않고 처리 가능

- 서버에서 data만 전송하면 되므로 전체 코딩의 양이 줄어든다.

- 기존 웹에서 불가능했떤 다양한 UI를 가능하게 해준다.

단점

- 히스토리 관리가 안 된다.(보안에 신경써야 한다.)

- 연속으로 데이터 응답요청시 부하가 증가할 수 잇다.

- XMLHTTPRequest를 통해 통신을 하는 경우 사용자에게 아무런 정보가 주어지지 않아서 아직 요청이 완료되지 않았는데 페이지를 떠나거나 오작동할 우려가 발생한다.

 

---------------- framework ---------------------

 

1. 프레임워크란 무엇인가

애플리케이션 개발에 바탕이 되는 템플릿과 같은 역할을 하는 클래스들과 인터페이스의 집합

 

2. 프레임워크와 라이브러리의 차이

라이브러리는 라이브러리를 가져다가 사용하고 호출하는 측에 전적으로 주도성이 있으며 프레임워크는 그 틀안에 이미 제어 흐름에 대한 주도성이 내포되어 있다.

 

3. 프레임워크의 특징

구조화된 스크립트를 통해 개발자의 스크립트 패턴을 정형화 할 수 있도록 되어있으며 개발자가 반복적으로 해야하는 공통부분을 최소화 할 수 있도록 설계되어 있다.

 

4. 프레임워크의 장단점

장점

- 체계적인 코드관리로 유지보수가 용이하다.

- 기본설계 및 기능 라이브러리를 제공하여 개발 생산성이 높다.

- 코드에 대한 재사용성이 높다.

- 추상화된 코드 제공을 통해 확장성이 좋다.

단점

- 학습난이도가 높다.

- 기본 설계된 구조에 의해 자유로운 개발에 한계가 있다.

- 사용하지 않는 기능에 대한 라이브러리가 포함될 수 있다.

- 제공되는 기능만큼 프로젝트의 용량이 증가한다.

 

5. 프레임워크의 종류

1. 스프링 프레임워크

2. 스트럿츠 프레임워크

3. 앵귤러 JS

4. 장고 프레임워크

 

6. 마이바티스란

객체 지향 언어인 자바의 관계형 데이터 베이스 프로그래밍을 보다 쉽게 도와주는 프레임 워크

 

7. 마이바티스의 장점

1. 쉬운 접근성과 코드의 간결함

2. SQL문과 프로그래밍 코드의 분리

3. 다양한 프로그래밍 언어로 구현가능

 

8. 메이븐이란

Apache Maven은 자바용 프로젝트 관리도구로 Apache Ant의 대안으로 만들어졌다.

Apache License로 배포되는 오픈 소스 소프트웨어이다.

 

9. 메이븐의 장점

1. 라이브러리의 관리를 매우 용이하게 해준다.

2. 프로젝트의 작성부터 컴파일, 페트스 등 프로젝트 라이프사이클에 포함되는 각 테스트를 지원해준다.

 

10. 스프링 프레임워크란

자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크로서 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션이다.

 

 

11. 스프링의 특징

1, 컨테이너 역할

2. DI지원

3. AOP지원

4. POJO지원

5. 트랜젝션 처리를 위한 일관된 방법을 지원

6. 영속성과 관련된 다양한 API지원

 

12. 스프링 MVC의 흐름(요청 처리 과정) - 말로도 설명해야 하고 그림도 그릴 수 있으면 좋음! <꽤 자주 나왔던 면접질문..

1. DispatcherServlet이 요청을 수신

2. DispatcherServlet은 HanderMapping에 클라이언트의 요청을 처리할 컨트롤러 객체를 요청

3. HandlerMapping은 요청을 처리할 컨트롤러를 검색해서 DispatcherServlet에 알려줌

4. DispatcherServlet은 해당 Controller에 처리를 요청

5. Controller는 처리 결과 및 뷰 정보를 ModelAndView에 담아 DispatcherServlet에 전달

6. DispatcherServlet은 처리 결과를 생성한 view를 구하기 위해 ViewResolver에 요청

7. ViewResolver는 처리결과를 생성할 view를 DispatcherServlet에 전달

8. DispatcherServlet은 view에 응답생성을 요청

9. view는 클라이언트에 전송할 응답을 생성

 

13. 처음 HelloWorld 화면이 나오게되는 원리 설명

1. 클라이언트 요청

2. web.xml 에서 디스패처 서블릿(Dispatcher Servlet) 클라이언트 요청을 핸들링

3. servlet-context.xml 에서 해당 클래스의 웹요청을 처리하는 컨트롤러를 사용 [HanderMapping으로 Controller 검색]

4. 해당 Controller 가 요청 처리 후, Home (View) 로 리턴 [뷰의 이름은 /WEB-INF/views/home.jsp 로 바뀐다.

5. View 에 출력

 

14. IoC란 무엇인가

제어의 역전. 메소드의 객체나 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것

 

15. IoC컨테이너에 대해 설명하시오

의존 객체 Bean을 만들어 Bean 객체간 의존성을 주입해주는 주체

 

16. IoC컨테이너의 역할

초기에 빈 오브젝트를 생성하고 DI(Dependency Injection)한 후에 최초로 애플리케이션을 기동할 빈 하나를 제공해주는 것

 

 

17. DI란 무엇인가

Dependency Injection - 의존성 주입

 

18. DI의 장점

1. Dependency Reduction : 객체 상호 간 의존성 관계를 줄여준다.

2. Reusable Structure : 코드의 재사용과 조합이 용이하다.

3. Readability : 코드들이 분리되다보니 가독성이 뛰어나진다.

4. Loose Coupling & Easy to change : 구조는 변화에 민감하지 않을 수 있다.

 

19. DI의 종류

1. Field Injection(필드 주입) : 변수 선언부에 @Autowired Annotaion을 붙인다.

2. Setter Injection(수정자 주입) : set Method를 정의해서 사용한다.

3. Constructor Injection(생성자 주입) : Constructor에 @Autowired Annotation을 붙여 의존성을 주입받는다.

 

20. xml을 이용한 bean관리와 어노테이션을 이용한 bean관리의 장단점

xml을 이용한 bean 관리

단점

- 빈의 성격구분을 하기 힘들다.

- 어플리케이션의 크기가 커질수록 xml파일에 작성되는 빈의 양이 커진다.

어노테이션을 이용한 bean 관리

장점

- 개발자가 특별한 선언을 하지 않아도 Component 관련 애노테이션만을 붙여주면 auto-scan되어 빈이 등록되게 된다.

 

21. 의존성 주입 시 사용하는 어노테이션과, 그 밖에 스프링에서 사용한 어노테이션에 대한 설명

@Autowired 어노테이션을 붙여 의존성을 주입한다.

- @Controller : 스프링MVC에서 컨트롤러 객체임을 명시하는 어노테이션

- @RequestMapping : 특정 URL에 매칭되는 클래스나 메소드임을 명시하는 어노테이션

- @RequestParam : 요청(request)에서 특정한 파라미터 값을 찾아낼 때 사용하는 어노테이션

- @ResponseBody : 리턴 타입이 HTTP응답 메시지로 전송

- @RequestBody : 요청(request)문자열이 그대로 파라미터로 전달

- @Service : 서비스 객체

- @SessionAttribute : 세션상에서 모델의 정보를 유지하고 싶은 경우에 사용

 

22. 가장 인상 깊게 사용한 어노테이션과 그 이유

- @SessionAttribute : 세션상에서 모델의 정보를 유지하고 싶은 경우에 사용

사용자의 로그인 정보를 유지할 때 사용했습니다.

 

 

23. AOP란

어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것

 

24. 스프링 AOP의 특징

1. Spring은 프록시 기반 AOP를 지원한다.

- Spring은 타겟(target) 객체에 대한 프록시를 만들어 제공한다.

- 타겟을 감싸는 프록시는 실행시간(Runtime)에 생성된다.

- 프록시는 어드바이스를 타겟 객체에 적용하면서 생성되는 객체이다.

2. 프록시(Proxy)가 호출을 가로챈다(Intercept)

- 프록시는 타겟 객체에 대한 호출을 가로챈 다음 어드바이스의 부가기능 로직을 수행하고 난 후에 타겟의 핵심기능 로직을 호출한다.(전처리 어드바이스)

- 또는 타겟의 핵심기능 로직 메서드를 호출한 후에 부가기능(어드바이스)을 수행하는 경우도 있다.(후처리 어드바이스)

3. Spring AOP는 메서드 조인 포인트만 지원한다.

- Spring은 동적 프록시를 기반으로 AOP를 구현하므로 메서드 조인 포인트만 지원한다.

- 핵심기능(타겟)의 메서드가 호출되는 런타임 시점에만 부가기능(어드바이스)을 적용할 수 있다.

 

25. Advice의 종류 및 설명

After returning - target의 메소드 호출 이후에 적용

After throwing - target의 예외 발생 후 적용

After - target의 메소드 호출 후 예외의 발생에 관계없이 적용

Around - target의 메소드 호출 이전과 이후 모두 적용 (가장 많이 사용됨)

 

26. AOP에 사용하는 어노테이션

@Component

- 컴포넌트 어노테이션을 명시해 스프링 컨테이너가 객체 생성하도록 한다.

@Aspect

- 스프링 컨테이너에 AOP 담당 객체임을 알린다.

@Around

- 횡단관심사항의 대상 지정과 적용 시점을 지정한다. (pointcut, advice)

Before Advice - target의 메소드 호출 전에 적용

 

27. MVC 아키텍처의 각 계층별 역할

1. 프리젠테이션 계층(Presentation Layer)

- 프리젠테이션 계층은 말 그대로 사용자 인터페이스에 불과하다

2. 제어 계층(Control Layer)

- 제어 계층은 프리젠테이션 계층과 비즈니스 로직 계층을 분리하기 위한 컨트롤러를 제공한다.

 

3. 비즈니스 로직 계층(Business Logic Layer)

- 핵심 업무를 어떻게 처리하는지에 대한 방법을 기술하는 곳이다.

4. 퍼시스턴스 계층(Persistence Layer)

- 주로 데이터의 생성/수정/삭제/선택(검색)과 같은 CRUD 연산을 수행

5.. 도메인 모델 계층(Domain Model Layer)

- 각 계층 사이에 전달되는 실질적인 비즈니스 객체

 

28. 스프링의 장점 3가지(스프링 3요소) <이거 진짜 면접때 자주 물어봤음!

1. 경량(Lightweight)

- 스프링은 여러 개의 모듈로 구성되어 있으며, 각 모듈은 하나 이상의 JAR 파일로 구성됨. 몇 개의 JAR 파일만 있으면 개발과 실행이 가능

- 스프링 프레임워크가 POJO(Plain Old Java Object)형태의 객체를 관리함.(POJO는 클래스를 구현하는데 특별한 규칙이 없다.)

2. 제어의 역행(Inversion of Control)

- 비즈니스 컴포넌트 개발 시 낮은 결합도와 높은 응집도 요구됨

- IoC를 통해 객체 간의 느슨한 결합, 즉 낮은 결합도를 유지함

- 기존에는 어플리케이션 수행에 필요한 객체의 생성이나 의존관계를 개발자가 직접 처리했으나, IoC가 적용되면 컨테이너가 대신 처리함

- 소스에 의존관계가 명시되지 않으므로 결합도가 ᄄᅠᆯ어져서 유지보수가 편리햊미

3. 관점지향 프로그래밍(Aspect Oriented Programming, AOP)

- 메소드를 개발할 때 비즈니스 메소드마다 반복되는 공통로직을 분리함

- 공통로직은 외부의 클래스로 분리하고, 해당 기능을 프로그램 코드에 명시적으로 표시하지 않고 선언적으로 처리해 적용한다.

- 공통기능을 분리함으로써 응집도가 높은 비즈니스 컴포넌트를 만들 수 있고 유지보수를 혁신적으로 향상시킴